{
  "version": 3,
  "sources": ["../../@trpc/react-query/dist/getArrayQueryKey-86134f8b.mjs", "../../@trpc/react-query/dist/createHooksInternal-063195fc.mjs", "../../@trpc/react-query/dist/index.mjs"],
  "sourcesContent": ["/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query. This function converts from the `.` separated\n * path passed around internally by both the legacy and proxy implementation.\n * https://github.com/trpc/trpc/issues/2611\n **/ function getArrayQueryKey(queryKey, type) {\n    const queryKeyArrayed = Array.isArray(queryKey) ? queryKey : [\n        queryKey\n    ];\n    const [path, input] = queryKeyArrayed;\n    const arrayPath = typeof path !== 'string' || path === '' ? [] : path.split('.');\n    // Construct a query key that is easy to destructure and flexible for\n    // partial selecting etc.\n    // https://github.com/trpc/trpc/issues/3128\n    if (!input && (!type || type === 'any')) // for `utils.invalidate()` to match all queries (including vanilla react-query)\n    // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n    return arrayPath.length ? [\n        arrayPath\n    ] : [];\n    return [\n        arrayPath,\n        {\n            ...typeof input !== 'undefined' && {\n                input: input\n            },\n            ...type && type !== 'any' && {\n                type: type\n            }\n        }\n    ];\n}\n\nexport { getArrayQueryKey as g };\n", "import { createRecursiveProxy, createFlatProxy } from '@trpc/server/shared';\nimport { g as getArrayQueryKey } from './getArrayQueryKey-86134f8b.mjs';\nimport { createTRPCClientProxy, createTRPCClient } from '@trpc/client';\nimport { useQuery, useQueryClient, useMutation, hashQueryKey, useInfiniteQuery, useQueries } from '@tanstack/react-query';\nimport React, { createContext, useMemo, useState, useEffect, useCallback, useRef } from 'react';\n\n/**\n * We treat `undefined` as an input the same as omitting an `input`\n * https://github.com/trpc/trpc/issues/2290\n */ function getQueryKeyInternal(path, input) {\n    if (path.length) return input === undefined ? [\n        path\n    ] : [\n        path,\n        input\n    ];\n    return [];\n}\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @link https://trpc.io/docs/getQueryKey\n */ function getQueryKey(..._params) {\n    const [procedureOrRouter, input, type] = _params;\n    // @ts-expect-error - we don't expose _def on the type layer\n    const path = procedureOrRouter._def().path;\n    const dotPath = path.join('.');\n    const queryKey = getArrayQueryKey(getQueryKeyInternal(dotPath, input), type ?? 'any');\n    return queryKey;\n}\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */ function createReactProxyDecoration(name, hooks) {\n    return createRecursiveProxy((opts)=>{\n        const args = opts.args;\n        const pathCopy = [\n            name,\n            ...opts.path\n        ];\n        // The last arg is for instance `.useMutation` or `.useQuery()`\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastArg = pathCopy.pop();\n        // The `path` ends up being something like `post.byId`\n        const path = pathCopy.join('.');\n        if (lastArg === 'useMutation') {\n            return hooks[lastArg](path, ...args);\n        }\n        const [input, ...rest] = args;\n        const queryKey = getQueryKeyInternal(path, input);\n        // Expose queryKey helper\n        if (lastArg === 'getQueryKey') {\n            return getArrayQueryKey(queryKey, rest[0] ?? 'any');\n        }\n        if (lastArg === '_def') {\n            return {\n                path: pathCopy\n            };\n        }\n        if (lastArg.startsWith('useSuspense')) {\n            const opts1 = rest[0] || {};\n            const fn = lastArg === 'useSuspenseQuery' ? 'useQuery' : 'useInfiniteQuery';\n            const result = hooks[fn](queryKey, {\n                ...opts1,\n                suspense: true,\n                enabled: true\n            });\n            return [\n                result.data,\n                result\n            ];\n        }\n        return hooks[lastArg](queryKey, ...rest);\n    });\n}\n\nconst contextProps = [\n    'client',\n    'ssrContext',\n    'ssrState',\n    'abortOnUnmount'\n];\nconst TRPCContext = /*#__PURE__*/ createContext(null);\n\n/**\n * @internal\n */ function createReactQueryUtilsProxy(context) {\n    return createFlatProxy((key)=>{\n        const contextName = key;\n        if (contextName === 'client') {\n            return createTRPCClientProxy(context.client);\n        }\n        if (contextProps.includes(contextName)) {\n            return context[contextName];\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const utilName = pathCopy.pop();\n            const fullPath = pathCopy.join('.');\n            const getOpts = (name)=>{\n                if ([\n                    'setData',\n                    'setInfiniteData'\n                ].includes(name)) {\n                    const [input, updater, ...rest] = args;\n                    const queryKey = getQueryKeyInternal(fullPath, input);\n                    return {\n                        queryKey,\n                        updater,\n                        rest\n                    };\n                }\n                const [input1, ...rest1] = args;\n                const queryKey1 = getQueryKeyInternal(fullPath, input1);\n                return {\n                    queryKey: queryKey1,\n                    rest: rest1\n                };\n            };\n            const { queryKey , rest , updater  } = getOpts(utilName);\n            const contextMap = {\n                fetch: ()=>context.fetchQuery(queryKey, ...rest),\n                fetchInfinite: ()=>context.fetchInfiniteQuery(queryKey, ...rest),\n                prefetch: ()=>context.prefetchQuery(queryKey, ...rest),\n                prefetchInfinite: ()=>context.prefetchInfiniteQuery(queryKey, ...rest),\n                ensureData: ()=>context.ensureQueryData(queryKey, ...rest),\n                invalidate: ()=>context.invalidateQueries(queryKey, ...rest),\n                reset: ()=>context.resetQueries(queryKey, ...rest),\n                refetch: ()=>context.refetchQueries(queryKey, ...rest),\n                cancel: ()=>context.cancelQuery(queryKey, ...rest),\n                setData: ()=>{\n                    context.setQueryData(queryKey, updater, ...rest);\n                },\n                setInfiniteData: ()=>{\n                    context.setInfiniteQueryData(queryKey, updater, ...rest);\n                },\n                getData: ()=>context.getQueryData(queryKey),\n                getInfiniteData: ()=>context.getInfiniteQueryData(queryKey)\n            };\n            return contextMap[utilName]();\n        });\n    });\n}\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */ function createUseQueriesProxy(client) {\n    return createRecursiveProxy((opts)=>{\n        const path = opts.path.join('.');\n        const [input, _opts] = opts.args;\n        const queryKey = getQueryKeyInternal(path, input);\n        const options = {\n            queryKey,\n            queryFn: ()=>{\n                return client.query(path, input, _opts?.trpc);\n            },\n            ..._opts\n        };\n        return options;\n    });\n}\n\nfunction getClientArgs(pathAndInput, opts) {\n    const [path, input] = pathAndInput;\n    return [\n        path,\n        input,\n        opts?.trpc\n    ];\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */ function useHookResult(value) {\n    const { path  } = value;\n    return useMemo(()=>({\n            path\n        }), [\n        path\n    ]);\n}\n\n/**\n * @internal\n */ function createRootHooks(config) {\n    const mutationSuccessOverride = (config?.overrides ?? config?.unstable_overrides)?.useMutation?.onSuccess ?? ((options)=>options.originalFn());\n    const Context = config?.context ?? TRPCContext;\n    const ReactQueryContext = config?.reactQueryContext;\n    const createClient = (opts)=>{\n        return createTRPCClient(opts);\n    };\n    const TRPCProvider = (props)=>{\n        const { abortOnUnmount =false , client , queryClient , ssrContext  } = props;\n        const [ssrState, setSSRState] = useState(props.ssrState ?? false);\n        useEffect(()=>{\n            // Only updating state to `mounted` if we are using SSR.\n            // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n            setSSRState((state)=>state ? 'mounted' : false);\n        }, []);\n        return /*#__PURE__*/ React.createElement(Context.Provider, {\n            value: {\n                abortOnUnmount,\n                queryClient,\n                client,\n                ssrContext: ssrContext ?? null,\n                ssrState,\n                fetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                fetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.fetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                prefetchInfiniteQuery: useCallback((pathAndInput, opts)=>{\n                    return queryClient.prefetchInfiniteQuery({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n                        queryFn: ({ pageParam  })=>{\n                            const [path, input] = pathAndInput;\n                            const actualInput = {\n                                ...input,\n                                cursor: pageParam\n                            };\n                            return client.query(...getClientArgs([\n                                path,\n                                actualInput\n                            ], opts));\n                        }\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                ensureQueryData: useCallback((pathAndInput, opts)=>{\n                    return queryClient.ensureQueryData({\n                        ...opts,\n                        queryKey: getArrayQueryKey(pathAndInput, 'query'),\n                        queryFn: ()=>client.query(...getClientArgs(pathAndInput, opts))\n                    });\n                }, [\n                    client,\n                    queryClient\n                ]),\n                invalidateQueries: useCallback((queryKey, filters, options)=>{\n                    return queryClient.invalidateQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                resetQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.resetQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                refetchQueries: useCallback((...args)=>{\n                    const [queryKey, filters, options] = args;\n                    return queryClient.refetchQueries({\n                        ...filters,\n                        queryKey: getArrayQueryKey(queryKey, 'any')\n                    }, options);\n                }, [\n                    queryClient\n                ]),\n                cancelQuery: useCallback((pathAndInput)=>{\n                    return queryClient.cancelQueries({\n                        queryKey: getArrayQueryKey(pathAndInput, 'any')\n                    });\n                }, [\n                    queryClient\n                ]),\n                setQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'query'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                setInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.setQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ]),\n                getInfiniteQueryData: useCallback((...args)=>{\n                    const [queryKey, ...rest] = args;\n                    return queryClient.getQueryData(getArrayQueryKey(queryKey, 'infinite'), ...rest);\n                }, [\n                    queryClient\n                ])\n            }\n        }, props.children);\n    };\n    function useContext() {\n        return React.useContext(Context);\n    }\n    /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @link https://github.com/trpc/trpc/pull/1645\n   */ function useSSRQueryOptionsIfNeeded(pathAndInput, type, opts) {\n        const { queryClient , ssrState  } = useContext();\n        return ssrState && ssrState !== 'mounted' && queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, type))?.state.status === 'error' ? {\n            retryOnMount: false,\n            ...opts\n        } : opts;\n    }\n    function useQuery$1(// FIXME path should be a tuple in next major\n    pathAndInput, opts) {\n        const context = useContext();\n        if (!context) {\n            throw new Error('Unable to retrieve application context. Did you forget to wrap your App inside `withTRPC` HoC?');\n        }\n        const { abortOnUnmount , client , ssrState , queryClient , prefetchQuery  } = context;\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'query'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'query'))) {\n            void prefetchQuery(pathAndInput, opts);\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'query', {\n            ...defaultOpts,\n            ...opts\n        });\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'query'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                return client.query(...getClientArgs(pathAndInput, actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path: pathAndInput[0]\n        });\n        return hook;\n    }\n    function useMutation$1(// FIXME: this should only be a tuple path in next major\n    path, opts) {\n        const { client  } = useContext();\n        const queryClient = useQueryClient({\n            context: ReactQueryContext\n        });\n        const actualPath = Array.isArray(path) ? path[0] : path;\n        const defaultOpts = queryClient.getMutationDefaults([\n            actualPath.split('.')\n        ]);\n        const hook = useMutation({\n            ...opts,\n            mutationKey: [\n                actualPath.split('.')\n            ],\n            mutationFn: (input)=>{\n                return client.mutation(...getClientArgs([\n                    actualPath,\n                    input\n                ], opts));\n            },\n            context: ReactQueryContext,\n            onSuccess (...args) {\n                const originalFn = ()=>opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n                return mutationSuccessOverride({\n                    originalFn,\n                    queryClient,\n                    meta: opts?.meta ?? defaultOpts?.meta ?? {}\n                });\n            }\n        });\n        hook.trpc = useHookResult({\n            path: actualPath\n        });\n        return hook;\n    }\n    /* istanbul ignore next -- @preserve */ function useSubscription(pathAndInput, opts) {\n        const enabled = opts?.enabled ?? true;\n        const queryKey = hashQueryKey(pathAndInput);\n        const { client  } = useContext();\n        const optsRef = useRef(opts);\n        optsRef.current = opts;\n        useEffect(()=>{\n            if (!enabled) {\n                return;\n            }\n            const [path, input] = pathAndInput;\n            let isStopped = false;\n            const subscription = client.subscription(path, input ?? undefined, {\n                onStarted: ()=>{\n                    if (!isStopped) {\n                        optsRef.current.onStarted?.();\n                    }\n                },\n                onData: (data)=>{\n                    if (!isStopped) {\n                        // FIXME this shouldn't be needed as both should be `unknown` in next major\n                        optsRef.current.onData(data);\n                    }\n                },\n                onError: (err)=>{\n                    if (!isStopped) {\n                        optsRef.current.onError?.(err);\n                    }\n                }\n            });\n            return ()=>{\n                isStopped = true;\n                subscription.unsubscribe();\n            };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            queryKey,\n            enabled\n        ]);\n    }\n    function useInfiniteQuery$1(pathAndInput, opts) {\n        const [path, input] = pathAndInput;\n        const { client , ssrState , prefetchInfiniteQuery , queryClient , abortOnUnmount ,  } = useContext();\n        const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, 'infinite'));\n        if (typeof window === 'undefined' && ssrState === 'prepass' && opts?.trpc?.ssr !== false && (opts?.enabled ?? defaultOpts?.enabled) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, 'infinite'))) {\n            void prefetchInfiniteQuery(pathAndInput, {\n                ...defaultOpts,\n                ...opts\n            });\n        }\n        const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, 'infinite', {\n            ...defaultOpts,\n            ...opts\n        });\n        // request option should take priority over global\n        const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n        const hook = useInfiniteQuery({\n            ...ssrOpts,\n            queryKey: getArrayQueryKey(pathAndInput, 'infinite'),\n            queryFn: (queryFunctionContext)=>{\n                const actualOpts = {\n                    ...ssrOpts,\n                    trpc: {\n                        ...ssrOpts?.trpc,\n                        ...shouldAbortOnUnmount ? {\n                            signal: queryFunctionContext.signal\n                        } : {}\n                    }\n                };\n                const actualInput = {\n                    ...input ?? {},\n                    cursor: queryFunctionContext.pageParam ?? opts?.initialCursor\n                };\n                // FIXME as any shouldn't be needed as client should be untyped too\n                return client.query(...getClientArgs([\n                    path,\n                    actualInput\n                ], actualOpts));\n            },\n            context: ReactQueryContext\n        });\n        hook.trpc = useHookResult({\n            path\n        });\n        return hook;\n    }\n    const useQueries$1 = (queriesCallback, context)=>{\n        const { ssrState , queryClient , prefetchQuery , client  } = useContext();\n        const proxy = createUseQueriesProxy(client);\n        const queries = queriesCallback(proxy);\n        if (typeof window === 'undefined' && ssrState === 'prepass') {\n            for (const query of queries){\n                const queryOption = query;\n                if (queryOption.trpc?.ssr !== false && !queryClient.getQueryCache().find(getArrayQueryKey(queryOption.queryKey, 'query'))) {\n                    void prefetchQuery(queryOption.queryKey, queryOption);\n                }\n            }\n        }\n        return useQueries({\n            queries: queries.map((query)=>({\n                    ...query,\n                    queryKey: getArrayQueryKey(query.queryKey, 'query')\n                })),\n            context\n        });\n    };\n    const useDehydratedState = (client, trpcState)=>{\n        const transformed = useMemo(()=>{\n            if (!trpcState) {\n                return trpcState;\n            }\n            return client.runtime.transformer.deserialize(trpcState);\n        }, [\n            trpcState,\n            client\n        ]);\n        return transformed;\n    };\n    return {\n        Provider: TRPCProvider,\n        createClient,\n        useContext,\n        useUtils: useContext,\n        useQuery: useQuery$1,\n        useQueries: useQueries$1,\n        useMutation: useMutation$1,\n        useSubscription,\n        useDehydratedState,\n        useInfiniteQuery: useInfiniteQuery$1\n    };\n}\n\n/**\n * Create strongly typed react hooks\n * @internal\n * @deprecated\n */ function createHooksInternal(config) {\n    return createRootHooks(config);\n}\n\nexport { TRPCContext as T, createReactQueryUtilsProxy as a, createReactProxyDecoration as b, createHooksInternal as c, getClientArgs as d, createUseQueriesProxy as e, createRootHooks as f, getQueryKey as g, contextProps as h };\n", "export * from '@trpc/client';\nimport { c as createHooksInternal, a as createReactQueryUtilsProxy, b as createReactProxyDecoration } from './createHooksInternal-063195fc.mjs';\nexport { g as getQueryKey } from './createHooksInternal-063195fc.mjs';\nimport { createFlatProxy } from '@trpc/server/shared';\nimport { useMemo } from 'react';\nimport '@tanstack/react-query';\nimport './getArrayQueryKey-86134f8b.mjs';\n\n/**\n * @internal\n */ function createHooksInternalProxy(trpc) {\n    return createFlatProxy((key)=>{\n        if (key === 'useContext' || key === 'useUtils') {\n            return ()=>{\n                const context = trpc.useUtils();\n                // create a stable reference of the utils context\n                return useMemo(()=>{\n                    return createReactQueryUtilsProxy(context);\n                }, [\n                    context\n                ]);\n            };\n        }\n        if (trpc.hasOwnProperty(key)) {\n            return trpc[key];\n        }\n        return createReactProxyDecoration(key, trpc);\n    });\n}\nfunction createTRPCReact(opts) {\n    const hooks = createHooksInternal(opts);\n    const proxy = createHooksInternalProxy(hooks);\n    return proxy;\n}\n\n// interop:\n/**\n * @deprecated use `createTRPCReact` instead\n */ function createReactQueryHooks(opts) {\n    const trpc = createHooksInternal(opts);\n    const proxy = createHooksInternalProxy(trpc);\n    return {\n        ...trpc,\n        proxy\n    };\n}\n\nexport { createReactQueryHooks, createTRPCReact };\n"],
  "mappings": "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",
  "names": ["updater", "rest", "queryKey", "React", "_a", "_b", "import_react"]
}
