import {
  TRPCClientError,
  TRPCUntypedClient,
  clientCallTypeToProcedureType,
  createFlatProxy,
  createRecursiveProxy,
  createTRPCClient,
  createTRPCClientProxy,
  createTRPCProxyClient,
  createTRPCUntypedClient,
  createWSClient,
  experimental_formDataLink,
  getFetch,
  getUntypedClient,
  httpBatchLink,
  httpLink,
  httpLinkFactory,
  loggerLink,
  splitLink,
  unstable_httpBatchStreamLink,
  wsLink
} from "./chunk-VS6JDKGL.js";
import {
  hashQueryKey,
  useInfiniteQuery,
  useMutation,
  useQueries,
  useQuery,
  useQueryClient
} from "./chunk-NQNAMMB4.js";
import "./chunk-6BKLQ22S.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@trpc/react-query/dist/getArrayQueryKey-86134f8b.mjs
function getArrayQueryKey(queryKey, type) {
  const queryKeyArrayed = Array.isArray(queryKey) ? queryKey : [
    queryKey
  ];
  const [path, input] = queryKeyArrayed;
  const arrayPath = typeof path !== "string" || path === "" ? [] : path.split(".");
  if (!input && (!type || type === "any"))
    return arrayPath.length ? [
      arrayPath
    ] : [];
  return [
    arrayPath,
    {
      ...typeof input !== "undefined" && {
        input
      },
      ...type && type !== "any" && {
        type
      }
    }
  ];
}

// node_modules/@trpc/react-query/dist/createHooksInternal-063195fc.mjs
var import_react = __toESM(require_react(), 1);
function getQueryKeyInternal(path, input) {
  if (path.length) return input === void 0 ? [
    path
  ] : [
    path,
    input
  ];
  return [];
}
function getQueryKey(..._params) {
  const [procedureOrRouter, input, type] = _params;
  const path = procedureOrRouter._def().path;
  const dotPath = path.join(".");
  const queryKey = getArrayQueryKey(getQueryKeyInternal(dotPath, input), type ?? "any");
  return queryKey;
}
function createReactProxyDecoration(name, hooks) {
  return createRecursiveProxy((opts) => {
    const args = opts.args;
    const pathCopy = [
      name,
      ...opts.path
    ];
    const lastArg = pathCopy.pop();
    const path = pathCopy.join(".");
    if (lastArg === "useMutation") {
      return hooks[lastArg](path, ...args);
    }
    const [input, ...rest] = args;
    const queryKey = getQueryKeyInternal(path, input);
    if (lastArg === "getQueryKey") {
      return getArrayQueryKey(queryKey, rest[0] ?? "any");
    }
    if (lastArg === "_def") {
      return {
        path: pathCopy
      };
    }
    if (lastArg.startsWith("useSuspense")) {
      const opts1 = rest[0] || {};
      const fn = lastArg === "useSuspenseQuery" ? "useQuery" : "useInfiniteQuery";
      const result = hooks[fn](queryKey, {
        ...opts1,
        suspense: true,
        enabled: true
      });
      return [
        result.data,
        result
      ];
    }
    return hooks[lastArg](queryKey, ...rest);
  });
}
var contextProps = [
  "client",
  "ssrContext",
  "ssrState",
  "abortOnUnmount"
];
var TRPCContext = (0, import_react.createContext)(null);
function createReactQueryUtilsProxy(context) {
  return createFlatProxy((key) => {
    const contextName = key;
    if (contextName === "client") {
      return createTRPCClientProxy(context.client);
    }
    if (contextProps.includes(contextName)) {
      return context[contextName];
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const utilName = pathCopy.pop();
      const fullPath = pathCopy.join(".");
      const getOpts = (name) => {
        if ([
          "setData",
          "setInfiniteData"
        ].includes(name)) {
          const [input, updater2, ...rest2] = args;
          const queryKey2 = getQueryKeyInternal(fullPath, input);
          return {
            queryKey: queryKey2,
            updater: updater2,
            rest: rest2
          };
        }
        const [input1, ...rest1] = args;
        const queryKey1 = getQueryKeyInternal(fullPath, input1);
        return {
          queryKey: queryKey1,
          rest: rest1
        };
      };
      const { queryKey, rest, updater } = getOpts(utilName);
      const contextMap = {
        fetch: () => context.fetchQuery(queryKey, ...rest),
        fetchInfinite: () => context.fetchInfiniteQuery(queryKey, ...rest),
        prefetch: () => context.prefetchQuery(queryKey, ...rest),
        prefetchInfinite: () => context.prefetchInfiniteQuery(queryKey, ...rest),
        ensureData: () => context.ensureQueryData(queryKey, ...rest),
        invalidate: () => context.invalidateQueries(queryKey, ...rest),
        reset: () => context.resetQueries(queryKey, ...rest),
        refetch: () => context.refetchQueries(queryKey, ...rest),
        cancel: () => context.cancelQuery(queryKey, ...rest),
        setData: () => {
          context.setQueryData(queryKey, updater, ...rest);
        },
        setInfiniteData: () => {
          context.setInfiniteQueryData(queryKey, updater, ...rest);
        },
        getData: () => context.getQueryData(queryKey),
        getInfiniteData: () => context.getInfiniteQueryData(queryKey)
      };
      return contextMap[utilName]();
    });
  });
}
function createUseQueriesProxy(client) {
  return createRecursiveProxy((opts) => {
    const path = opts.path.join(".");
    const [input, _opts] = opts.args;
    const queryKey = getQueryKeyInternal(path, input);
    const options = {
      queryKey,
      queryFn: () => {
        return client.query(path, input, _opts == null ? void 0 : _opts.trpc);
      },
      ..._opts
    };
    return options;
  });
}
function getClientArgs(pathAndInput, opts) {
  const [path, input] = pathAndInput;
  return [
    path,
    input,
    opts == null ? void 0 : opts.trpc
  ];
}
function useHookResult(value) {
  const { path } = value;
  return (0, import_react.useMemo)(() => ({
    path
  }), [
    path
  ]);
}
function createRootHooks(config) {
  var _a, _b;
  const mutationSuccessOverride = ((_b = (_a = (config == null ? void 0 : config.overrides) ?? (config == null ? void 0 : config.unstable_overrides)) == null ? void 0 : _a.useMutation) == null ? void 0 : _b.onSuccess) ?? ((options) => options.originalFn());
  const Context = (config == null ? void 0 : config.context) ?? TRPCContext;
  const ReactQueryContext = config == null ? void 0 : config.reactQueryContext;
  const createClient = (opts) => {
    return createTRPCClient(opts);
  };
  const TRPCProvider = (props) => {
    const { abortOnUnmount = false, client, queryClient, ssrContext } = props;
    const [ssrState, setSSRState] = (0, import_react.useState)(props.ssrState ?? false);
    (0, import_react.useEffect)(() => {
      setSSRState((state) => state ? "mounted" : false);
    }, []);
    return import_react.default.createElement(Context.Provider, {
      value: {
        abortOnUnmount,
        queryClient,
        client,
        ssrContext: ssrContext ?? null,
        ssrState,
        fetchQuery: (0, import_react.useCallback)((pathAndInput, opts) => {
          return queryClient.fetchQuery({
            ...opts,
            queryKey: getArrayQueryKey(pathAndInput, "query"),
            queryFn: () => client.query(...getClientArgs(pathAndInput, opts))
          });
        }, [
          client,
          queryClient
        ]),
        fetchInfiniteQuery: (0, import_react.useCallback)((pathAndInput, opts) => {
          return queryClient.fetchInfiniteQuery({
            ...opts,
            queryKey: getArrayQueryKey(pathAndInput, "infinite"),
            queryFn: ({ pageParam }) => {
              const [path, input] = pathAndInput;
              const actualInput = {
                ...input,
                cursor: pageParam
              };
              return client.query(...getClientArgs([
                path,
                actualInput
              ], opts));
            }
          });
        }, [
          client,
          queryClient
        ]),
        prefetchQuery: (0, import_react.useCallback)((pathAndInput, opts) => {
          return queryClient.prefetchQuery({
            ...opts,
            queryKey: getArrayQueryKey(pathAndInput, "query"),
            queryFn: () => client.query(...getClientArgs(pathAndInput, opts))
          });
        }, [
          client,
          queryClient
        ]),
        prefetchInfiniteQuery: (0, import_react.useCallback)((pathAndInput, opts) => {
          return queryClient.prefetchInfiniteQuery({
            ...opts,
            queryKey: getArrayQueryKey(pathAndInput, "infinite"),
            queryFn: ({ pageParam }) => {
              const [path, input] = pathAndInput;
              const actualInput = {
                ...input,
                cursor: pageParam
              };
              return client.query(...getClientArgs([
                path,
                actualInput
              ], opts));
            }
          });
        }, [
          client,
          queryClient
        ]),
        ensureQueryData: (0, import_react.useCallback)((pathAndInput, opts) => {
          return queryClient.ensureQueryData({
            ...opts,
            queryKey: getArrayQueryKey(pathAndInput, "query"),
            queryFn: () => client.query(...getClientArgs(pathAndInput, opts))
          });
        }, [
          client,
          queryClient
        ]),
        invalidateQueries: (0, import_react.useCallback)((queryKey, filters, options) => {
          return queryClient.invalidateQueries({
            ...filters,
            queryKey: getArrayQueryKey(queryKey, "any")
          }, options);
        }, [
          queryClient
        ]),
        resetQueries: (0, import_react.useCallback)((...args) => {
          const [queryKey, filters, options] = args;
          return queryClient.resetQueries({
            ...filters,
            queryKey: getArrayQueryKey(queryKey, "any")
          }, options);
        }, [
          queryClient
        ]),
        refetchQueries: (0, import_react.useCallback)((...args) => {
          const [queryKey, filters, options] = args;
          return queryClient.refetchQueries({
            ...filters,
            queryKey: getArrayQueryKey(queryKey, "any")
          }, options);
        }, [
          queryClient
        ]),
        cancelQuery: (0, import_react.useCallback)((pathAndInput) => {
          return queryClient.cancelQueries({
            queryKey: getArrayQueryKey(pathAndInput, "any")
          });
        }, [
          queryClient
        ]),
        setQueryData: (0, import_react.useCallback)((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.setQueryData(getArrayQueryKey(queryKey, "query"), ...rest);
        }, [
          queryClient
        ]),
        getQueryData: (0, import_react.useCallback)((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.getQueryData(getArrayQueryKey(queryKey, "query"), ...rest);
        }, [
          queryClient
        ]),
        setInfiniteQueryData: (0, import_react.useCallback)((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.setQueryData(getArrayQueryKey(queryKey, "infinite"), ...rest);
        }, [
          queryClient
        ]),
        getInfiniteQueryData: (0, import_react.useCallback)((...args) => {
          const [queryKey, ...rest] = args;
          return queryClient.getQueryData(getArrayQueryKey(queryKey, "infinite"), ...rest);
        }, [
          queryClient
        ])
      }
    }, props.children);
  };
  function useContext() {
    return import_react.default.useContext(Context);
  }
  function useSSRQueryOptionsIfNeeded(pathAndInput, type, opts) {
    var _a2;
    const { queryClient, ssrState } = useContext();
    return ssrState && ssrState !== "mounted" && ((_a2 = queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, type))) == null ? void 0 : _a2.state.status) === "error" ? {
      retryOnMount: false,
      ...opts
    } : opts;
  }
  function useQuery$1(pathAndInput, opts) {
    var _a2, _b2;
    const context = useContext();
    if (!context) {
      throw new Error("Unable to retrieve application context. Did you forget to wrap your App inside `withTRPC` HoC?");
    }
    const { abortOnUnmount, client, ssrState, queryClient, prefetchQuery } = context;
    const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, "query"));
    if (typeof window === "undefined" && ssrState === "prepass" && ((_a2 = opts == null ? void 0 : opts.trpc) == null ? void 0 : _a2.ssr) !== false && ((opts == null ? void 0 : opts.enabled) ?? (defaultOpts == null ? void 0 : defaultOpts.enabled)) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, "query"))) {
      void prefetchQuery(pathAndInput, opts);
    }
    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, "query", {
      ...defaultOpts,
      ...opts
    });
    const shouldAbortOnUnmount = ((_b2 = opts == null ? void 0 : opts.trpc) == null ? void 0 : _b2.abortOnUnmount) ?? (config == null ? void 0 : config.abortOnUnmount) ?? abortOnUnmount;
    const hook = useQuery({
      ...ssrOpts,
      queryKey: getArrayQueryKey(pathAndInput, "query"),
      queryFn: (queryFunctionContext) => {
        const actualOpts = {
          ...ssrOpts,
          trpc: {
            ...ssrOpts == null ? void 0 : ssrOpts.trpc,
            ...shouldAbortOnUnmount ? {
              signal: queryFunctionContext.signal
            } : {}
          }
        };
        return client.query(...getClientArgs(pathAndInput, actualOpts));
      },
      context: ReactQueryContext
    });
    hook.trpc = useHookResult({
      path: pathAndInput[0]
    });
    return hook;
  }
  function useMutation$1(path, opts) {
    const { client } = useContext();
    const queryClient = useQueryClient({
      context: ReactQueryContext
    });
    const actualPath = Array.isArray(path) ? path[0] : path;
    const defaultOpts = queryClient.getMutationDefaults([
      actualPath.split(".")
    ]);
    const hook = useMutation({
      ...opts,
      mutationKey: [
        actualPath.split(".")
      ],
      mutationFn: (input) => {
        return client.mutation(...getClientArgs([
          actualPath,
          input
        ], opts));
      },
      context: ReactQueryContext,
      onSuccess(...args) {
        const originalFn = () => {
          var _a2, _b2;
          return ((_a2 = opts == null ? void 0 : opts.onSuccess) == null ? void 0 : _a2.call(opts, ...args)) ?? ((_b2 = defaultOpts == null ? void 0 : defaultOpts.onSuccess) == null ? void 0 : _b2.call(defaultOpts, ...args));
        };
        return mutationSuccessOverride({
          originalFn,
          queryClient,
          meta: (opts == null ? void 0 : opts.meta) ?? (defaultOpts == null ? void 0 : defaultOpts.meta) ?? {}
        });
      }
    });
    hook.trpc = useHookResult({
      path: actualPath
    });
    return hook;
  }
  function useSubscription(pathAndInput, opts) {
    const enabled = (opts == null ? void 0 : opts.enabled) ?? true;
    const queryKey = hashQueryKey(pathAndInput);
    const { client } = useContext();
    const optsRef = (0, import_react.useRef)(opts);
    optsRef.current = opts;
    (0, import_react.useEffect)(() => {
      if (!enabled) {
        return;
      }
      const [path, input] = pathAndInput;
      let isStopped = false;
      const subscription = client.subscription(path, input ?? void 0, {
        onStarted: () => {
          var _a2, _b2;
          if (!isStopped) {
            (_b2 = (_a2 = optsRef.current).onStarted) == null ? void 0 : _b2.call(_a2);
          }
        },
        onData: (data) => {
          if (!isStopped) {
            optsRef.current.onData(data);
          }
        },
        onError: (err) => {
          var _a2, _b2;
          if (!isStopped) {
            (_b2 = (_a2 = optsRef.current).onError) == null ? void 0 : _b2.call(_a2, err);
          }
        }
      });
      return () => {
        isStopped = true;
        subscription.unsubscribe();
      };
    }, [
      queryKey,
      enabled
    ]);
  }
  function useInfiniteQuery$1(pathAndInput, opts) {
    var _a2, _b2;
    const [path, input] = pathAndInput;
    const { client, ssrState, prefetchInfiniteQuery, queryClient, abortOnUnmount } = useContext();
    const defaultOpts = queryClient.getQueryDefaults(getArrayQueryKey(pathAndInput, "infinite"));
    if (typeof window === "undefined" && ssrState === "prepass" && ((_a2 = opts == null ? void 0 : opts.trpc) == null ? void 0 : _a2.ssr) !== false && ((opts == null ? void 0 : opts.enabled) ?? (defaultOpts == null ? void 0 : defaultOpts.enabled)) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(pathAndInput, "infinite"))) {
      void prefetchInfiniteQuery(pathAndInput, {
        ...defaultOpts,
        ...opts
      });
    }
    const ssrOpts = useSSRQueryOptionsIfNeeded(pathAndInput, "infinite", {
      ...defaultOpts,
      ...opts
    });
    const shouldAbortOnUnmount = ((_b2 = opts == null ? void 0 : opts.trpc) == null ? void 0 : _b2.abortOnUnmount) ?? abortOnUnmount;
    const hook = useInfiniteQuery({
      ...ssrOpts,
      queryKey: getArrayQueryKey(pathAndInput, "infinite"),
      queryFn: (queryFunctionContext) => {
        const actualOpts = {
          ...ssrOpts,
          trpc: {
            ...ssrOpts == null ? void 0 : ssrOpts.trpc,
            ...shouldAbortOnUnmount ? {
              signal: queryFunctionContext.signal
            } : {}
          }
        };
        const actualInput = {
          ...input ?? {},
          cursor: queryFunctionContext.pageParam ?? (opts == null ? void 0 : opts.initialCursor)
        };
        return client.query(...getClientArgs([
          path,
          actualInput
        ], actualOpts));
      },
      context: ReactQueryContext
    });
    hook.trpc = useHookResult({
      path
    });
    return hook;
  }
  const useQueries$1 = (queriesCallback, context) => {
    var _a2;
    const { ssrState, queryClient, prefetchQuery, client } = useContext();
    const proxy = createUseQueriesProxy(client);
    const queries = queriesCallback(proxy);
    if (typeof window === "undefined" && ssrState === "prepass") {
      for (const query of queries) {
        const queryOption = query;
        if (((_a2 = queryOption.trpc) == null ? void 0 : _a2.ssr) !== false && !queryClient.getQueryCache().find(getArrayQueryKey(queryOption.queryKey, "query"))) {
          void prefetchQuery(queryOption.queryKey, queryOption);
        }
      }
    }
    return useQueries({
      queries: queries.map((query) => ({
        ...query,
        queryKey: getArrayQueryKey(query.queryKey, "query")
      })),
      context
    });
  };
  const useDehydratedState = (client, trpcState) => {
    const transformed = (0, import_react.useMemo)(() => {
      if (!trpcState) {
        return trpcState;
      }
      return client.runtime.transformer.deserialize(trpcState);
    }, [
      trpcState,
      client
    ]);
    return transformed;
  };
  return {
    Provider: TRPCProvider,
    createClient,
    useContext,
    useUtils: useContext,
    useQuery: useQuery$1,
    useQueries: useQueries$1,
    useMutation: useMutation$1,
    useSubscription,
    useDehydratedState,
    useInfiniteQuery: useInfiniteQuery$1
  };
}
function createHooksInternal(config) {
  return createRootHooks(config);
}

// node_modules/@trpc/react-query/dist/index.mjs
var import_react2 = __toESM(require_react(), 1);
function createHooksInternalProxy(trpc) {
  return createFlatProxy((key) => {
    if (key === "useContext" || key === "useUtils") {
      return () => {
        const context = trpc.useUtils();
        return (0, import_react2.useMemo)(() => {
          return createReactQueryUtilsProxy(context);
        }, [
          context
        ]);
      };
    }
    if (trpc.hasOwnProperty(key)) {
      return trpc[key];
    }
    return createReactProxyDecoration(key, trpc);
  });
}
function createTRPCReact(opts) {
  const hooks = createHooksInternal(opts);
  const proxy = createHooksInternalProxy(hooks);
  return proxy;
}
function createReactQueryHooks(opts) {
  const trpc = createHooksInternal(opts);
  const proxy = createHooksInternalProxy(trpc);
  return {
    ...trpc,
    proxy
  };
}
export {
  TRPCClientError,
  TRPCUntypedClient,
  clientCallTypeToProcedureType,
  createReactQueryHooks,
  createTRPCClient,
  createTRPCClientProxy,
  createTRPCProxyClient,
  createTRPCReact,
  createTRPCUntypedClient,
  createWSClient,
  experimental_formDataLink,
  getFetch,
  getQueryKey,
  getUntypedClient,
  httpBatchLink,
  httpLink,
  httpLinkFactory,
  loggerLink,
  splitLink,
  unstable_httpBatchStreamLink,
  wsLink
};
/*! Bundled license information:

@trpc/react-query/dist/createHooksInternal-063195fc.mjs:
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=@trpc_react-query.js.map
